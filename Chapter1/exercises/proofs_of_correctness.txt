1-7: **Prove the correctness of the following recursive algorithm to multiply two
natural numbers, for all integer constants c ≥ 2.
function multiply(y,z)
	comment Return the product yz.
	1. if z = 0 then return(0) else
	2. return(multiply(cy, floor(z/c)) + y · (z mod c))**

	case 1: c = z
		multiply(y,z) = multiply(cy, floor(z/c)) + y · (z mod c)
					  = multiply(zy, floor(z/z)) + y · (z mod z)
					  = multiply(zy, 1) + y · (z mod z)
					  = multiply(zy, 1) 
					  = multiply(czy, floor(1/c)) + zy*(1 mod c) 
					  = multiply(zzy, floor(1/z)) + zy*(1 mod z) 
					  = multiply(zzy, 0) + zy*(1 mod z) 
					  = yz
					  OK!
					 

	case 2: c > z
		multiply(y,z) = multiply(cy, floor(z/c)) + y · (z mod c)
					  = multiply(cy, 0) + y · (z mod c)
					  = multiply(cy, 0) + y · (z mod c)
					  = yz
					  OK!


	case 3: c < z
		c >= 2
		z <= n //indutive hypothesis
		y >= 0
		base Case: z = 0, multiply(y,0) = 0 which is true
		lemma: we show that floor(z/c)*c + (z mod c) = z ::
			by the quotient remainder theorem z = cq + r
												= cq + z mod c
												.:
											z = floor(z/c)*c + (z mod c) (**1)
		Assuming the algorithm holds for all nums <= n we must show that multiply(y, n + 1) = y*(n+1)
			multiply(y, n + 1) = multiply(cy, floor((n+1)/c)) + y*((n+1) mod c)
			since c >= 2, floor((n+1)/c) < n + 1 :. the first term returns a valid result (based on our inductive hypothesis) so following the algorithm
			multiply(y, n + 1) = multiply(cy, floor((n+1)/c)) + y*((n+1) mod c) // let z = n+1
							   = cy*floor((z`)/c) + y*((z`) mod c)
							   =y*(c*floor(z`/c) + (z` mod c)) 
							   and from (1)
							   = y*z`
							   = y*(n+1)
							   OK!



1-8: **Prove the correctness of the following algorithm for evaluating a polynomial.
P(x) = anxn + an−1xn−1 + ... + a1x + a0
function horner(A, x)
	p = An
	for i from n − 1 to 0
	p = p ∗ x + Ai
	return p **




1-9: **Prove the correctness of the following sorting algorithm.
function bubblesort (A : list[1 ...n])
	var int i, j
	for i from n to 1
	for j from 1 to i − 1
	if (A[j] > A[j + 1])
	swap the values of A[j] and A[j + 1]**